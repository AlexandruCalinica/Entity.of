<h1 style="font-size: 3rem;">Entity.of ðŸ‘»</h1>

[![CI](https://github.com/AlexandruCalinica/Entity.of/actions/workflows/workflow.yaml/badge.svg?branch=main)](https://github.com/AlexandruCalinica/Entity.of/actions/workflows/workflow.yaml)
[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)
[![semantic-release: angular](https://img.shields.io/badge/semantic--release-angular-e10079?logo=semantic-release)](https://github.com/semantic-release/semantic-release)
<a href="https://www.npmjs.com/package/entity-of">
  <img alt="npm latest version" src="https://img.shields.io/npm/v/entity-of/latest.svg">
</a>
<A href="https://www.npmjs.com/package/entity-of">
  <img alt="" src="https://img.shields.io/npm/l/entity-of" />
</a>

- ## ðŸ•¸ Data inconsistency catcher
- ## ðŸ¦¾ Declarative API contract enforcer
- ## ðŸ›  Standardized object constructor

**Entity.of** ensures that the data received over the wire matches your expectations. When it doesn't you'll know first. ðŸš¨

The motivation behind **Entity.of** comes from first degree encounters with broken APIs, out-of-date REST api documentations, unsynchronized graphql schemas + resolvers, third party services releasing breaking changes, and many more text-book or edge case situations causing bugs, unexplained behaviours, runtime errors and generally a bad user experience for end users.
